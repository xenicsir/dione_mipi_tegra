From fefe4826032e6c4309d2311fd8856ae388ced58c Mon Sep 17 00:00:00 2001
From: Botond Kardos <bkardos70@gmail.com>
Date: Mon, 21 Mar 2022 15:02:45 +0000
Subject: [PATCH] unified dione_ir driver supports dione640 and dione1280
 sensors

---
 drivers/base/regmap/regmap.c                  |   70 +
 include/linux/regmap.h                        |    4 +
 nvidia/drivers/media/i2c/Kconfig              |    9 +
 nvidia/drivers/media/i2c/Makefile             |    1 +
 nvidia/drivers/media/i2c/dione_ir.c           | 1531 +++++++++++++++++
 nvidia/drivers/media/i2c/tc358746_regs.h      |  210 +++
 .../tegra210-camera-rbpcv2-dione-ir.dtsi      |  344 ++++
 .../tegra210-porg-camera-rbpcv2-dione-ir.dtsi |   42 +
 .../porg-platforms/tegra210-porg-camera.dtsi  |    2 +-
 .../tegra210-porg-plugin-manager.dtsi         |   79 +-
 .../tegra210-porg-p3448-common.dtsi           |    2 +-
 11 files changed, 2256 insertions(+), 38 deletions(-)
 create mode 100644 nvidia/drivers/media/i2c/dione_ir.c
 create mode 100644 nvidia/drivers/media/i2c/tc358746_regs.h
 create mode 100644 nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi
 create mode 100644 nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi

diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
index 4965abd6c6c9..17f304371c5b 100644
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -263,6 +263,30 @@ static void regmap_format_32_le(void *buf, unsigned int val, unsigned int shift)
 	b[0] = cpu_to_le32(val << shift);
 }
 
+static void regmap_format_32_lbe(void *buf, unsigned int val, unsigned int shift)
+{
+	u8 *b = buf;
+
+	val <<= shift;
+
+	b[0] = val >> 16;
+	b[1] = val >> 24;
+	b[2] = val;
+	b[3] = val >> 8;
+}
+
+static void regmap_format_32_ble(void *buf, unsigned int val, unsigned int shift)
+{
+	u8 *b = buf;
+
+	val <<= shift;
+
+	b[0] = val >> 8;
+	b[1] = val;
+	b[2] = val >> 24;
+	b[3] = val >> 16;
+}
+
 static void regmap_format_32_native(void *buf, unsigned int val,
 				    unsigned int shift)
 {
@@ -359,6 +383,28 @@ static unsigned int regmap_parse_32_le(const void *buf)
 	return le32_to_cpu(b[0]);
 }
 
+static unsigned int regmap_parse_32_lbe(const void *buf)
+{
+	const u8 *b = buf;
+	unsigned int ret = b[2];
+	ret |= ((unsigned int)b[3]) << 8;
+	ret |= ((unsigned int)b[0]) << 16;
+	ret |= ((unsigned int)b[1]) << 24;
+
+	return ret;
+}
+
+static unsigned int regmap_parse_32_ble(const void *buf)
+{
+	const u8 *b = buf;
+	unsigned int ret = b[1];
+	ret |= ((unsigned int)b[0]) << 8;
+	ret |= ((unsigned int)b[3]) << 16;
+	ret |= ((unsigned int)b[2]) << 24;
+
+	return ret;
+}
+
 static void regmap_parse_32_be_inplace(void *buf)
 {
 	__be32 *b = buf;
@@ -373,6 +419,20 @@ static void regmap_parse_32_le_inplace(void *buf)
 	b[0] = le32_to_cpu(b[0]);
 }
 
+static void regmap_parse_32_lbe_inplace(void *buf)
+{
+	u32 *b = buf;
+
+	b[0] = regmap_parse_32_lbe(buf);
+}
+
+static void regmap_parse_32_ble_inplace(void *buf)
+{
+	u32 *b = buf;
+
+	b[0] = regmap_parse_32_ble(buf);
+}
+
 static unsigned int regmap_parse_32_native(const void *buf)
 {
 	return *(u32 *)buf;
@@ -875,6 +935,16 @@ struct regmap *__regmap_init(struct device *dev,
 			map->format.parse_val = regmap_parse_32_le;
 			map->format.parse_inplace = regmap_parse_32_le_inplace;
 			break;
+		case REGMAP_ENDIAN_LITTLE_BIG:
+			map->format.format_val = regmap_format_32_lbe;
+			map->format.parse_val = regmap_parse_32_lbe;
+			map->format.parse_inplace = regmap_parse_32_lbe_inplace;
+			break;
+		case REGMAP_ENDIAN_BIG_LITTLE:
+			map->format.format_val = regmap_format_32_ble;
+			map->format.parse_val = regmap_parse_32_ble;
+			map->format.parse_inplace = regmap_parse_32_ble_inplace;
+			break;
 		case REGMAP_ENDIAN_NATIVE:
 			map->format.format_val = regmap_format_32_native;
 			map->format.parse_val = regmap_parse_32_native;
diff --git a/include/linux/regmap.h b/include/linux/regmap.h
index e85d110fbdfb..5caae1ca4966 100644
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@ -143,6 +143,10 @@ enum regmap_endian {
 	REGMAP_ENDIAN_BIG,
 	REGMAP_ENDIAN_LITTLE,
 	REGMAP_ENDIAN_NATIVE,
+	/* Mixed endian: be words in le order (like on PDP-11), 2-1-4-3 */
+	REGMAP_ENDIAN_BIG_LITTLE,
+	/* Mixed endian: le words in be order, 3-4-1-2 */
+	REGMAP_ENDIAN_LITTLE_BIG,
 };
 
 /**
diff --git a/nvidia/drivers/media/i2c/Kconfig b/nvidia/drivers/media/i2c/Kconfig
index 326dbb096017..59e4b2990b41 100644
--- a/nvidia/drivers/media/i2c/Kconfig
+++ b/nvidia/drivers/media/i2c/Kconfig
@@ -3,6 +3,15 @@ if VIDEO_V4L2
 menu "NVIDIA overlay Encoders, decoders, sensors and other helper chips"
 	visible if !MEDIA_SUBDRV_AUTOSELECT || COMPILE_TEST
 
+config VIDEO_DIONE_IR
+	tristate "DIONE IR camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports DIONE640 and DIONE1280 infra camera sensors from Xenics
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called dione_ir.
+
 config VIDEO_IMX185
 	tristate "IMX185 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/nvidia/drivers/media/i2c/Makefile b/nvidia/drivers/media/i2c/Makefile
index c6d34e8077e3..37ae5ca39de5 100644
--- a/nvidia/drivers/media/i2c/Makefile
+++ b/nvidia/drivers/media/i2c/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_VIDEO_LT6911UXC) +=lt6911uxc.o
 obj-$(CONFIG_I2C_IOEXPANDER_SER_MAX9295) += max9295.o
 obj-$(CONFIG_I2C_IOEXPANDER_DESER_MAX9296) += max9296.o
 obj-$(CONFIG_VIDEO_IMX390) += imx390.o
+obj-$(CONFIG_VIDEO_DIONE_IR) += dione_ir.o
diff --git a/nvidia/drivers/media/i2c/dione_ir.c b/nvidia/drivers/media/i2c/dione_ir.c
new file mode 100644
index 000000000000..f9929714dc6b
--- /dev/null
+++ b/nvidia/drivers/media/i2c/dione_ir.c
@@ -0,0 +1,1531 @@
+/*
+ * dione_ir.c - Dione IR sensor driver
+ *
+ * Copyright (c) 2021-2022, Xenics Infrared Solutions.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "tc358746_regs.h"
+
+
+#define DIONE640_I2C_ADDR              0x5a
+#define DIONE640_REG_WIDTH             0x00080188
+#define DIONE640_REG_WIDTH_MAX         0x0002f028
+#define DIONE640_REG_FIRMWARE_VERSION  0x2000e000
+
+#define DIONE640_STARTUP_TMO_MS        12000
+
+#define DIONE1280_I2C_ADDR             0x5b
+#define DIONE1280_REG_WIDTH_MAX        0x0002f028
+#define DIONE1280_REG_HEIGHT_MAX       0x0002f02c
+#define DIONE1280_REG_MODEL_NAME       0x00000044
+#define DIONE1280_REG_FIRMWARE_VERSION 0x2000e000
+#define DIONE1280_REG_ACQUISITION_STOP 0x00080104
+#define DIONE1280_REG_ACQUISITION_SRC  0x00080108
+#define DIONE1280_REG_ACQUISITION_STAT 0x0008010c
+
+#define DIONE1280_I2C_TMO_MS           5
+#define DIONE1280_STARTUP_TMO_MS       15000
+
+
+static int test_mode = 0;
+static int quick_mode = 1;
+module_param(test_mode, int, 0644);
+module_param(quick_mode, int, 0644);
+
+enum {
+	DIONE_IR_MODE_640x480_60FPS,
+	DIONE_IR_MODE_1280x1024_60FPS,
+};
+
+static const int dioneir_60fps[] = {
+	60,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in
+ * device tree!
+ */
+static const struct camera_common_frmfmt dioneir_frmfmt_common[] = {
+	{{640, 480},	dioneir_60fps, 1, 0, DIONE_IR_MODE_640x480_60FPS},
+	{{1280, 1024},	dioneir_60fps, 1, 0, DIONE_IR_MODE_1280x1024_60FPS},
+	/* Add modes with no device tree support after below */
+};
+
+static const struct regmap_range ctl_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0000, 0x00ff),
+};
+
+static const struct regmap_access_table ctl_regmap_access = {
+	.yes_ranges = ctl_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(ctl_regmap_rw_ranges),
+};
+
+static const struct regmap_config ctl_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 2,
+	.val_bits = 16,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x00ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.rd_table = &ctl_regmap_access,
+	.wr_table = &ctl_regmap_access,
+	.name = "tc358746-ctl",
+};
+
+static const struct regmap_range tx_regmap_rw_ranges[] = {
+	regmap_reg_range(0x0100, 0x05ff),
+};
+
+static const struct regmap_access_table tx_regmap_access = {
+	.yes_ranges = tx_regmap_rw_ranges,
+	.n_yes_ranges = ARRAY_SIZE(tx_regmap_rw_ranges),
+};
+
+static const struct regmap_config tx_regmap_config = {
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.cache_type = REGCACHE_NONE,
+	.max_register = 0x05ff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG_LITTLE,
+	.rd_table = &tx_regmap_access,
+	.wr_table = &tx_regmap_access,
+	.name = "tc358746-tx",
+};
+
+static const struct of_device_id dioneir_of_match[] = {
+	{ .compatible = "xenics,dione_ir", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, dioneir_of_match);
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+};
+
+struct dione_struct {
+	struct i2c_client		*tc35_client;
+	struct i2c_client		*fpga_client;
+	struct v4l2_subdev		*subdev;
+	struct regmap			*tx_regmap;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
+	ktime_t					start_up;
+};
+
+
+struct tc358746_param {
+	/* clock */
+	bool is_continuous_clk;
+	u16 pll_prd;
+	u16 pll_fbd;
+	u16 pll_frs;
+
+	/* CSI2-TX Parameters */
+	u32 lineinitcnt;
+	u32 lptxtimecnt;
+	u32 twakeupcnt;
+	u32 tclk_preparecnt;
+	u32 tclk_zerocnt;
+	u32 tclk_trailcnt;
+	u32 tclk_postcnt;
+	u32 ths_preparecnt;
+	u32 ths_zerocnt;
+	u32 ths_trailcnt;
+	u32 hstxvregcnt;
+
+	/* other */
+	int lane_num;
+	u32 fmt_width;
+	u16 vb_fifo;
+	u8 pdformat;
+	u8 pdataf;
+	u8 bpp;
+};
+
+const struct tc358746_param dione640_params = {
+	.is_continuous_clk = false,
+	.pll_prd = 3,
+	.pll_fbd = 82,
+	.pll_frs = 1,
+
+	.lineinitcnt = 4000,
+	.lptxtimecnt = 3,
+	.tclk_preparecnt = 2,
+	.tclk_zerocnt = 18,
+	.tclk_trailcnt = 1,
+	.ths_preparecnt = 3,
+	.ths_zerocnt = 0,
+	.twakeupcnt = 17000,
+	.tclk_postcnt = 0,
+	.ths_trailcnt = 1,
+	.hstxvregcnt = 5,
+
+	.lane_num = 2,
+	.fmt_width = 640,
+	.vb_fifo = 247,
+	.pdformat = 0x3,
+	.pdataf = 0,
+	.bpp = 24
+};
+
+const struct tc358746_param dione1280_params = {
+	.is_continuous_clk = true,
+	.pll_prd = 3,
+	.pll_fbd = 125,
+	.pll_frs = 0,
+
+	.lineinitcnt = 6500,
+	.lptxtimecnt = 6,
+	.tclk_preparecnt = 6,
+	.tclk_zerocnt = 35,
+	.tclk_trailcnt = 4,
+	.ths_preparecnt = 6,
+	.ths_zerocnt = 8,
+	.twakeupcnt = 25000,
+	.tclk_postcnt = 12,
+	.ths_trailcnt = 5,
+	.hstxvregcnt = 5,
+
+	.lane_num = 2,
+	.fmt_width = 1280,
+	.vb_fifo = 2,
+	.pdformat = 0x3,
+	.pdataf = 0,
+	.bpp = 24
+};
+
+/* CSI and other tc358746 settings for supported modes */
+const struct tc358746_param dioneir_mode_params[] = {
+	dione640_params,
+	dione1280_params
+};
+
+static int dione1280_i2c_read(struct i2c_client *client, u32 addr, u8 *buf, u16 len);
+static int dione1280_i2c_write32(struct i2c_client *client, u32 addr, u32 val);
+
+
+static inline int dioneir_read_reg(struct camera_common_data *s_data,
+	u16 addr, u8 *val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xff;
+
+	return err;
+}
+
+static inline int dioneir_write_reg(struct camera_common_data *s_data,
+	u16 addr, u8 val)
+{
+	int err = 0;
+
+	err = regmap_write(s_data->regmap, addr, val);
+	if (err)
+		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int dioneir_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%d\n", __func__, val);
+	return 0;
+}
+
+static int dioneir_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dioneir_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static int dioneir_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	dev_dbg(tc_dev->dev, "%s val=%lld\n", __func__, val);
+	return 0;
+}
+
+static struct tegracam_ctrl_ops dioneir_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.set_gain = dioneir_set_gain,
+	.set_exposure = dioneir_set_exposure,
+	.set_frame_rate = dioneir_set_frame_rate,
+	.set_group_hold = dioneir_set_group_hold,
+};
+
+static int dioneir_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto dioneir_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto dioneir_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto dioneir_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	usleep_range(23000, 23100);
+	msleep(200);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+dioneir_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+dioneir_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+dioneir_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int dioneir_power_off_dummy(struct camera_common_data *s_data)
+{
+	return 0;
+}
+
+static int dioneir_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 1);
+			else
+				gpio_set_value(pw->reset_gpio, 1);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int dioneir_power_on_reva(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 0);
+		else
+			gpio_set_value(pw->reset_gpio, 0);
+	}
+
+	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
+		goto skip_power_seqn;
+
+	usleep_range(10, 20);
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		if (err)
+			goto dioneir_avdd_fail;
+	}
+
+	if (pw->iovdd) {
+		err = regulator_enable(pw->iovdd);
+		if (err)
+			goto dioneir_iovdd_fail;
+	}
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		if (err)
+			goto dioneir_dvdd_fail;
+	}
+
+	usleep_range(10, 20);
+
+skip_power_seqn:
+	if (pw->reset_gpio) {
+		if (gpio_cansleep(pw->reset_gpio))
+			gpio_set_value_cansleep(pw->reset_gpio, 1);
+		else
+			gpio_set_value(pw->reset_gpio, 1);
+	}
+
+	usleep_range(23000, 23100);
+	msleep(200);
+
+	pw->state = SWITCH_ON;
+
+	return 0;
+
+dioneir_dvdd_fail:
+	regulator_disable(pw->iovdd);
+
+dioneir_iovdd_fail:
+	regulator_disable(pw->avdd);
+
+dioneir_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+
+	return -ENODEV;
+}
+
+static int dioneir_power_off_reva(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (err) {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	} else {
+		if (pw->reset_gpio) {
+			if (gpio_cansleep(pw->reset_gpio))
+				gpio_set_value_cansleep(pw->reset_gpio, 0);
+			else
+				gpio_set_value(pw->reset_gpio, 0);
+		}
+
+		usleep_range(10, 10);
+
+		if (pw->dvdd)
+			regulator_disable(pw->dvdd);
+		if (pw->iovdd)
+			regulator_disable(pw->iovdd);
+		if (pw->avdd)
+			regulator_disable(pw->avdd);
+	}
+
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int dioneir_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	s_data->ops->power_off(s_data);
+
+	if (likely(pw->dvdd))
+		devm_regulator_put(pw->dvdd);
+
+	if (likely(pw->avdd))
+		devm_regulator_put(pw->avdd);
+
+	if (likely(pw->iovdd))
+		devm_regulator_put(pw->iovdd);
+
+	pw->dvdd = NULL;
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (likely(pw->reset_gpio))
+		gpio_free(pw->reset_gpio);
+
+	if (priv->fpga_client != NULL) {
+		i2c_unregister_device(priv->fpga_client);
+		priv->fpga_client = NULL;
+	}
+
+	return 0;
+}
+
+static int dioneir_power_get(struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct clk *parent;
+	int err = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	/* Sensor MCLK (aka. INCK) */
+	if (pdata->mclk_name) {
+		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
+		if (IS_ERR(pw->mclk)) {
+			dev_err(dev, "unable to get clock %s\n",
+				pdata->mclk_name);
+			return PTR_ERR(pw->mclk);
+		}
+
+		if (pdata->parentclk_name) {
+			parent = devm_clk_get(dev, pdata->parentclk_name);
+			if (IS_ERR(parent)) {
+				dev_err(dev, "unable to get parent clock %s",
+					pdata->parentclk_name);
+			} else
+				clk_set_parent(pw->mclk, parent);
+		}
+	}
+
+	/* analog 2.8v */
+	if (pdata->regulators.avdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->avdd, pdata->regulators.avdd);
+	/* IO 1.8v */
+	if (pdata->regulators.iovdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->iovdd, pdata->regulators.iovdd);
+	/* dig 1.2v */
+	if (pdata->regulators.dvdd)
+		err |= camera_common_regulator_get(dev,
+				&pw->dvdd, pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
+		goto done;
+	}
+
+	/* Reset or ENABLE GPIO */
+	pw->reset_gpio = pdata->reset_gpio;
+	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+	if (err < 0) {
+		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+			__func__, err);
+		goto done;
+	}
+
+done:
+	pw->state = SWITCH_OFF;
+
+	return err;
+}
+
+static struct camera_common_pdata *dioneir_parse_dt(
+	struct tegracam_device *tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	struct camera_common_pdata *ret = NULL;
+	int err = 0;
+	int gpio;
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(dioneir_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+		sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER)
+			ret = ERR_PTR(-EPROBE_DEFER);
+		dev_err(dev, "reset-gpios not found\n");
+		goto error;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
+	if (err)
+		dev_dbg(dev, "mclk name not present, "
+			"assume sensor driven externally\n");
+
+	err = of_property_read_string(np, "avdd-reg",
+		&board_priv_pdata->regulators.avdd);
+	err |= of_property_read_string(np, "iovdd-reg",
+		&board_priv_pdata->regulators.iovdd);
+	err |= of_property_read_string(np, "dvdd-reg",
+		&board_priv_pdata->regulators.dvdd);
+	if (err)
+		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
+			"assume sensor powered independently\n");
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(np, "has-eeprom");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+
+	return ret;
+}
+
+static inline int tc358746_sleep_mode(struct regmap *regmap, int enable)
+{
+	return regmap_update_bits(regmap, SYSCTL, SYSCTL_SLEEP_MASK,
+				  enable ? SYSCTL_SLEEP_MASK : 0);
+}
+
+static inline int tc358746_sreset(struct regmap *regmap)
+{
+	int err;
+
+	err = regmap_write(regmap, SYSCTL, SYSCTL_SRESET_MASK);
+
+	udelay(10);
+
+	if (!err)
+		err = regmap_write(regmap, SYSCTL, 0);
+
+	return err;
+}
+
+static int tc358746_set_pll(struct regmap *regmap,
+							const struct tc358746_param *csi_param)
+{
+	u32 pllctl0, pllctl1, pllctl0_new;
+	int err;
+
+	err = regmap_read(regmap, PLLCTL0, &pllctl0);
+	if (!err)
+		err = regmap_read(regmap, PLLCTL1, &pllctl1);
+
+	if (err)
+		return err;
+
+	pllctl0_new = PLLCTL0_PLL_PRD_SET(csi_param->pll_prd) |
+	  PLLCTL0_PLL_FBD_SET(csi_param->pll_fbd);
+
+	/*
+	 * Only rewrite when needed (new value or disabled), since rewriting
+	 * triggers another format change event.
+	 */
+
+	if (pllctl0 != pllctl0_new || (pllctl1 & PLLCTL1_PLL_EN_MASK) == 0) {
+		u16 pllctl1_mask = PLLCTL1_PLL_FRS_MASK | PLLCTL1_RESETB_MASK |
+				   PLLCTL1_PLL_EN_MASK;
+		u16 pllctl1_val = PLLCTL1_PLL_FRS_SET(csi_param->pll_frs) |
+				  PLLCTL1_RESETB_MASK | PLLCTL1_PLL_EN_MASK;
+
+		err = regmap_write(regmap, PLLCTL0, pllctl0_new);
+		if (!err)
+			err = regmap_update_bits(regmap, PLLCTL1,
+						 pllctl1_mask, pllctl1_val);
+		udelay(1000);
+
+		if (!err)
+			err = regmap_update_bits(regmap, PLLCTL1,
+						 PLLCTL1_CKEN_MASK,
+						 PLLCTL1_CKEN_MASK);
+	}
+
+	return err;
+}
+
+static int tc358746_set_csi_color_space(struct regmap *regmap,
+										const struct tc358746_param *csi_param)
+{
+	int err;
+
+	err = regmap_update_bits(regmap, DATAFMT,
+				 (DATAFMT_PDFMT_MASK | DATAFMT_UDT_EN_MASK),
+				 DATAFMT_PDFMT_SET(csi_param->pdformat));
+
+	if (!err)
+		err = regmap_update_bits(regmap, CONFCTL, CONFCTL_PDATAF_MASK,
+					 CONFCTL_PDATAF_SET(csi_param->pdataf));
+
+	return err;
+}
+
+static int tc358746_set_buffers(struct regmap *regmap,
+								const struct tc358746_param *csi_param)
+{
+	unsigned int byte_per_line = (csi_param->fmt_width * csi_param->bpp) / 8;
+	int err;
+
+	err = regmap_write(regmap, FIFOCTL, csi_param->vb_fifo);
+
+	if (!err)
+		err = regmap_write(regmap, WORDCNT, byte_per_line);
+
+	return err;
+}
+
+static int tc358746_enable_csi_lanes(struct regmap *regmap,
+		int lane_num, int enable)
+{
+	u32 val = 0;
+	int err = 0;
+
+	if (lane_num < 1 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, CLW_CNTRL,
+					   CLW_CNTRL_CLW_LANEDISABLE_MASK);
+		if (!err)
+			err = regmap_write(regmap, D0W_CNTRL,
+					   D0W_CNTRL_D0W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 2 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D1W_CNTRL,
+					   D1W_CNTRL_D1W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 3 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D2W_CNTRL,
+					   D2W_CNTRL_D2W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num < 4 || !enable) {
+		if (!err)
+			err = regmap_write(regmap, D3W_CNTRL,
+					   D2W_CNTRL_D3W_LANEDISABLE_MASK);
+	}
+
+	if (lane_num > 0 && enable) {
+		val |= HSTXVREGEN_CLM_HSTXVREGEN_MASK |
+			HSTXVREGEN_D0M_HSTXVREGEN_MASK;
+	}
+
+	if (lane_num > 1 && enable)
+		val |= HSTXVREGEN_D1M_HSTXVREGEN_MASK;
+
+	if (lane_num > 2 && enable)
+		val |= HSTXVREGEN_D2M_HSTXVREGEN_MASK;
+
+	if (lane_num > 3 && enable)
+		val |= HSTXVREGEN_D3M_HSTXVREGEN_MASK;
+
+	if (!err)
+		err = regmap_write(regmap, HSTXVREGEN, val);
+
+	return err;
+}
+
+static int tc358746_set_csi(struct regmap *regmap,
+							const struct tc358746_param *param)
+{
+	u32 val;
+	int err;
+
+	val = TCLK_HEADERCNT_TCLK_ZEROCNT_SET(param->tclk_zerocnt) |
+	      TCLK_HEADERCNT_TCLK_PREPARECNT_SET(param->tclk_preparecnt);
+	err = regmap_write(regmap, TCLK_HEADERCNT, val);
+
+	val = THS_HEADERCNT_THS_ZEROCNT_SET(param->ths_zerocnt) |
+	      THS_HEADERCNT_THS_PREPARECNT_SET(param->ths_preparecnt);
+	if (!err)
+		err = regmap_write(regmap, THS_HEADERCNT, val);
+
+	if (!err)
+		err = regmap_write(regmap, TWAKEUP, param->twakeupcnt);
+
+	if (!err)
+		err = regmap_write(regmap, TCLK_POSTCNT, param->tclk_postcnt);
+
+	if (!err)
+		err = regmap_write(regmap, THS_TRAILCNT, param->ths_trailcnt);
+
+	if (!err)
+		err = regmap_write(regmap, LINEINITCNT, param->lineinitcnt);
+
+	if (!err)
+		err = regmap_write(regmap, LPTXTIMECNT, param->lptxtimecnt);
+
+	if (!err)
+		err = regmap_write(regmap, TCLK_TRAILCNT, param->tclk_trailcnt);
+
+	if (!err)
+		err = regmap_write(regmap, HSTXVREGCNT, param->hstxvregcnt);
+
+	val = param->is_continuous_clk ? TXOPTIONCNTRL_CONTCLKMODE_MASK : 0;
+	if (!err)
+		err = regmap_write(regmap, TXOPTIONCNTRL, val);
+
+	return err;
+}
+
+static int tc358746_wr_csi_control(struct regmap *regmap, u32 val)
+{
+	u32 _val;
+
+	val &= CSI_CONFW_DATA_MASK;
+	_val = CSI_CONFW_MODE_SET_MASK | CSI_CONFW_ADDRESS_CSI_CONTROL_MASK |
+		val;
+
+	return regmap_write(regmap, CSI_CONFW, _val);
+}
+
+static int tc358746_enable_csi_module(struct regmap *regmap, int lane_num)
+{
+	u32 val;
+	int err;
+
+	err = regmap_write(regmap, STARTCNTRL, STARTCNTRL_START_MASK);
+
+	if (!err)
+		err = regmap_write(regmap, CSI_START, CSI_START_STRT_MASK);
+
+	val = CSI_CONTROL_NOL_1_MASK;
+	if (lane_num == 2)
+		val = CSI_CONTROL_NOL_2_MASK;
+	else if (lane_num == 3)
+		val = CSI_CONTROL_NOL_3_MASK;
+	else if (lane_num == 4)
+		val = CSI_CONTROL_NOL_4_MASK;
+
+	val |= CSI_CONTROL_CSI_MODE_MASK | CSI_CONTROL_TXHSMD_MASK |
+		CSI_CONTROL_EOTDIS_MASK; /* add according to excell */
+
+	if (!err)
+		err = tc358746_wr_csi_control(regmap, val);
+
+	return err;
+}
+
+static int dioneir_set_mode_common(struct tegracam_device *tc_dev, s64 tmo_startup)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	const struct tc358746_param *csi_setting;
+	int err;
+
+	err = 0;
+	if (test_mode) {
+		/* wait until FPGA in sensor finishes booting up */
+		while(ktime_ms_delta(ktime_get(), priv->start_up) < tmo_startup)
+			msleep(100);
+
+		/* enable test pattern in the sensor module */
+		err = dione1280_i2c_write32(priv->fpga_client, DIONE1280_REG_ACQUISITION_STOP, 2);
+		if (!err) {
+			msleep(300);
+			err = dione1280_i2c_write32(priv->fpga_client, DIONE1280_REG_ACQUISITION_SRC, 0);
+		}
+
+		if (!err) {
+			msleep(300);
+			err = dione1280_i2c_write32(priv->fpga_client, DIONE1280_REG_ACQUISITION_STOP, 1);
+		}
+	}
+
+	csi_setting = &dioneir_mode_params[s_data->mode];
+
+	regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	if (!err)
+		err = tc358746_sreset(ctl_regmap);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to reset chip\n");
+		return err;
+	}
+
+	err = tc358746_set_pll(ctl_regmap, csi_setting);
+	if (err) {
+		dev_err(tc_dev->dev, "Failed to setup PLL\n");
+		return err;
+	}
+
+	err = tc358746_set_csi_color_space(ctl_regmap, csi_setting);
+
+	if (!err)
+		err = tc358746_set_buffers(ctl_regmap, csi_setting);
+
+	if (!err)
+		err = tc358746_enable_csi_lanes(tx_regmap, csi_setting->lane_num, true);
+
+	if (!err)
+		err = tc358746_set_csi(tx_regmap, csi_setting);
+
+	if (!err)
+		err = tc358746_enable_csi_module(tx_regmap, csi_setting->lane_num);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dione640_set_mode(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+
+	if (s_data->mode != DIONE_IR_MODE_640x480_60FPS)
+		return -EINVAL;
+
+	return dioneir_set_mode_common(tc_dev, DIONE640_STARTUP_TMO_MS);
+}
+
+static int dione1280_set_mode(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+
+	if (s_data->mode != DIONE_IR_MODE_1280x1024_60FPS)
+		return -EINVAL;
+
+	return dioneir_set_mode_common(tc_dev, DIONE1280_STARTUP_TMO_MS);
+}
+
+
+static int dioneir_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	int err;
+
+	err = regmap_write(ctl_regmap, PP_MISC, 0);
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, CONFCTL,
+								 CONFCTL_PPEN_MASK,
+								 CONFCTL_PPEN_MASK);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static int dioneir_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct dione_struct *priv = (struct dione_struct *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = priv->s_data;
+	struct regmap *ctl_regmap = s_data->regmap;
+	struct regmap *tx_regmap = priv->tx_regmap;
+	int err;
+
+	err = regmap_update_bits(ctl_regmap, PP_MISC, PP_MISC_FRMSTOP_MASK,
+				 PP_MISC_FRMSTOP_MASK);
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, CONFCTL,
+					 CONFCTL_PPEN_MASK, 0);
+
+	if (!err)
+		err = regmap_update_bits(ctl_regmap, PP_MISC,
+					 PP_MISC_RSTPTR_MASK,
+					 PP_MISC_RSTPTR_MASK);
+
+	if (!err)
+		err = regmap_write(tx_regmap, CSIRESET,
+				   (CSIRESET_RESET_CNF_MASK |
+				    CSIRESET_RESET_MODULE_MASK));
+	if (!err)
+		err = regmap_write(ctl_regmap, DBG_ACT_LINE_CNT, 0);
+
+	if (err)
+		dev_err(tc_dev->dev, "%s return code (%d)\n", __func__, err);
+	return err;
+}
+
+static struct camera_common_sensor_ops dione640_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(dioneir_frmfmt_common),
+	.frmfmt_table = dioneir_frmfmt_common,
+	.power_on = dioneir_power_on,
+	.power_off = dioneir_power_off,
+	.write_reg = dioneir_write_reg,
+	.read_reg = dioneir_read_reg,
+	.parse_dt = dioneir_parse_dt,
+	.power_get = dioneir_power_get,
+	.power_put = dioneir_power_put,
+	.set_mode = dione640_set_mode,
+	.start_streaming = dioneir_start_streaming,
+	.stop_streaming = dioneir_stop_streaming,
+};
+
+static struct camera_common_sensor_ops dione640_reva_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(dioneir_frmfmt_common),
+	.frmfmt_table = dioneir_frmfmt_common,
+	.power_on = dioneir_power_on_reva,
+	.power_off = dioneir_power_off_reva,
+	.write_reg = dioneir_write_reg,
+	.read_reg = dioneir_read_reg,
+	.parse_dt = dioneir_parse_dt,
+	.power_get = dioneir_power_get,
+	.power_put = dioneir_power_put,
+	.set_mode = dione640_set_mode,
+	.start_streaming = dioneir_start_streaming,
+	.stop_streaming = dioneir_stop_streaming,
+};
+
+static struct camera_common_sensor_ops dione1280_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(dioneir_frmfmt_common),
+	.frmfmt_table = dioneir_frmfmt_common,
+	.power_on = dioneir_power_on,
+	.power_off = dioneir_power_off,
+	.write_reg = dioneir_write_reg,
+	.read_reg = dioneir_read_reg,
+	.parse_dt = dioneir_parse_dt,
+	.power_get = dioneir_power_get,
+	.power_put = dioneir_power_put,
+	.set_mode = dione1280_set_mode,
+	.start_streaming = dioneir_start_streaming,
+	.stop_streaming = dioneir_stop_streaming,
+};
+
+static int dione640_i2c_read(struct i2c_client *client, u32 dev_addr, void *dst,
+							size_t len)
+{
+	struct i2c_msg msgs[2];
+	u8 tmp_buf[72];
+	int ret;
+
+	ret = 0;
+	if (len > sizeof(tmp_buf) - 2)
+		ret = -1;
+
+	if (!ret) {
+		*( (u32 *)tmp_buf ) = dev_addr;
+		*( (u16 *)tmp_buf + 2 ) = len;
+
+		msgs[0].addr = client->addr;
+		msgs[0].flags = 0;
+		msgs[0].len = 6;
+		msgs[0].buf = tmp_buf;
+
+		msgs[1].addr = client->addr;
+		msgs[1].flags = I2C_M_RD;
+		msgs[1].len = len + 2;
+		msgs[1].buf = tmp_buf;
+
+		if (i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs)) != 2)
+			ret = -1;
+	}
+
+	if (!ret) {
+		if ((tmp_buf[0] != 0) || (tmp_buf[1] != 0))
+			ret = -1;
+		else
+			memcpy(dst, tmp_buf+2, len);
+	}
+
+	return ret;
+} /* dione640_i2c_read */
+
+
+static int generic_i2c_read(struct i2c_client *client, void *buf, size_t len)
+{
+	struct i2c_msg msgs[1];
+	int ret;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = I2C_M_RD;
+	msgs[0].len = len;
+	msgs[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	return ret;
+} /* generic_i2c_read */
+
+
+static int generic_i2c_write(struct i2c_client *client, void *buf, size_t len)
+{
+	struct i2c_msg msgs[1];
+	int ret;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = len;
+	msgs[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	return ret;
+} /* generic_i2c_write */
+
+
+static int dione1280_i2c_read( struct i2c_client *client, u32 addr, u8 *buf, u16 len )
+{
+	u8 tmp_buf[72];
+	int ret, tmo, retry;
+
+	ret = 0;
+	if (len > sizeof(tmp_buf) - 2)
+		ret = -1;
+
+	if (!ret) {
+		*( (u32 *)tmp_buf ) = addr;
+		*( (u16 *)tmp_buf + 2 ) = len;
+		retry = 4;
+		tmo = DIONE1280_I2C_TMO_MS ;
+		ret = -1;
+		while (retry-- > 0) {
+			if (generic_i2c_write(client, tmp_buf, 6) == 1) {
+				ret = 0;
+				break;
+			}
+			msleep(tmo);
+			tmo <<= 2;
+		}
+	}
+
+	if (!ret) {
+		retry = 4;
+		tmo = DIONE1280_I2C_TMO_MS ;
+		ret = -1;
+		msleep(2);
+		while (retry-- > 0) {
+			if (generic_i2c_read(client, tmp_buf, len+2) == 1) {
+				ret = 0;
+				break;
+			}
+			msleep(tmo);
+			tmo <<= 2;
+		}
+	}
+
+	if (!ret) {
+		if ((tmp_buf[0] != 0) || (tmp_buf[1] != 0))
+			ret = -1;
+		else
+			memcpy(buf, tmp_buf+2, len);
+	}
+
+	return ret;
+}
+
+static int dione1280_i2c_write32(struct i2c_client *client, u32 addr, u32 val)
+{
+	u8 tmp_buf[10];
+	int ret, tmo, retry;
+
+	ret = 0;
+	*( (u32 *)tmp_buf ) = addr;
+	*( (u16 *)tmp_buf + 2 ) = 4;
+	memcpy(tmp_buf + 6, &val, 4);
+	retry = 4;
+	tmo = DIONE1280_I2C_TMO_MS;
+	ret = -1;
+	while (retry-- > 0) {
+		if (generic_i2c_write(client, tmp_buf, 10) == 1) {
+			ret = 0;
+			break;
+		}
+		msleep(tmo);
+		tmo <<= 2;
+	}
+
+	return ret;
+}
+
+static int detect_dione640(struct dione_struct *priv)
+{
+	struct device *dev = priv->s_data->dev;
+	u8 buf[64];
+	u32 reg_val;
+	int cnt;
+	int ret = 0;
+
+	msleep(200);
+
+	priv->fpga_client = i2c_new_dummy(priv->tc35_client->adapter, DIONE640_I2C_ADDR);
+
+	if (!priv->fpga_client)
+		ret = -ENODEV;
+
+	if (!ret) {
+		ret = dione640_i2c_read(priv->fpga_client, DIONE640_REG_WIDTH_MAX, (u8 *)&reg_val, 4);
+		if (ret || (reg_val != 640))
+			ret = -ENODEV;
+	}
+
+	if (!ret ) {
+		ret = dione640_i2c_read(priv->fpga_client, DIONE640_REG_FIRMWARE_VERSION, buf, 64);
+		if (!ret) {
+			cnt = 63;
+			while ((cnt > 0) && (buf[cnt] == 0xff))
+				buf[cnt--] = 0;
+			dev_info(dev, "FirmwareVersion: %s\n", buf);
+		}
+	}
+
+	if (ret)
+		if (priv->fpga_client != NULL) {
+			i2c_unregister_device(priv->fpga_client);
+			priv->fpga_client = NULL;
+		}
+
+	return ret;
+}
+
+static int detect_dione1280(struct dione_struct *priv)
+{
+	struct device *dev = priv->s_data->dev;
+	u8 buf[64];
+	u32 reg_val;
+	int cnt;
+	int ret = 0;
+
+	msleep(500);
+
+	priv->fpga_client = i2c_new_dummy(priv->tc35_client->adapter, DIONE1280_I2C_ADDR);
+
+	if (!priv->fpga_client)
+		ret = -ENODEV;
+
+	if (!ret) {
+		ret = dione1280_i2c_read(priv->fpga_client, DIONE1280_REG_WIDTH_MAX, (u8 *)&reg_val, 4);
+		if (ret || (reg_val != 1280))
+			ret = -ENODEV;
+	}
+
+	if (!ret) {
+		ret = dione1280_i2c_read(priv->fpga_client, DIONE1280_REG_FIRMWARE_VERSION, buf, 64);
+		if (!ret) {
+			cnt = 63;
+			while ((cnt > 0) && (buf[cnt] == 0xff))
+				buf[cnt--] = 0;
+			dev_info(dev, "FirmwareVersion: %s\n", buf);
+		}
+	}
+
+	if (ret)
+		if (priv->fpga_client != NULL) {
+			i2c_unregister_device(priv->fpga_client);
+			priv->fpga_client = NULL;
+		}
+
+	return ret;
+}
+
+static int dioneir_board_setup(struct dione_struct *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	struct regmap *ctl_regmap = s_data->regmap;
+	u32 reg_val;
+	int err = 0;
+
+	if (pdata->mclk_name) {
+		err = camera_common_mclk_enable(s_data);
+		if (err) {
+			dev_err(dev, "error turning on mclk (%d)\n", err);
+			goto done;
+		}
+	}
+
+	err = s_data->ops->power_on(s_data);
+	if (err) {
+		dev_err(dev, "error during power on sensor (%d)\n", err);
+		goto err_power_on;
+	}
+
+	if ((s_data->ops == &dione640_common_ops) || (s_data->ops == &dione640_reva_common_ops))
+		err = detect_dione640(priv);
+
+	if (s_data->ops == &dione1280_common_ops)
+		err = detect_dione1280(priv);
+
+	if (err)
+		goto err_reg_probe;
+
+	/* Probe sensor model id registers */
+	err = regmap_read(ctl_regmap, CHIPID, &reg_val);
+	if (err) {
+		dev_err(dev, "%s: error during i2c read probe (%d)\n",
+			__func__, err);
+		goto err_reg_probe;
+	}
+
+	if ((reg_val & CHIPID_CHIPID_MASK) != 0x4400) {
+		dev_err(dev, "%s: invalid sensor model id: %x\n",
+			__func__, reg_val);
+		err = -ENODEV;
+		goto err_reg_probe;
+	}
+
+err_reg_probe:
+	s_data->ops->power_off(s_data);
+
+err_power_on:
+	if (pdata->mclk_name)
+		camera_common_mclk_disable(s_data);
+
+done:
+	return err;
+}
+
+static int dioneir_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops dioneir_subdev_internal_ops = {
+	.open = dioneir_open,
+};
+
+static struct tegracam_device *dioneir_probe_one( struct dione_struct *priv,
+												  struct camera_common_sensor_ops *ops )
+{
+	struct tegracam_device *tc_dev;
+	struct device *dev = &priv->tc35_client->dev;
+	int err;
+
+	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return NULL;
+
+	tc_dev->client = priv->tc35_client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "dione_ir", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &ctl_regmap_config;
+	tc_dev->sensor_ops = ops;
+	if (quick_mode)
+		ops->power_off = dioneir_power_off_dummy;
+	tc_dev->v4l2sd_internal_ops = &dioneir_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &dioneir_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		devm_kfree(tc_dev->dev, tc_dev);
+		tc_dev = NULL;
+		dev_err(dev, "tegra camera driver registration failed\n");
+	}
+
+	if (!err) {
+		priv->tc_dev = tc_dev;
+		priv->s_data = tc_dev->s_data;
+		priv->subdev = &tc_dev->s_data->subdev;
+		tegracam_set_privdata(tc_dev, (void *)priv);
+
+		priv->tx_regmap = devm_regmap_init_i2c(priv->tc35_client,
+											   &tx_regmap_config);
+		if (IS_ERR(priv->tx_regmap)) {
+			dev_err(dev, "tx_regmap init failed: %ld\n",
+					PTR_ERR(priv->tx_regmap));
+			err = -ENODEV;
+		}
+	}
+
+	if (!err)
+		err = dioneir_board_setup(priv);
+
+	priv->start_up = ktime_get();
+	if (err) {
+		if (!!tc_dev)
+			tegracam_device_unregister(tc_dev);
+		tc_dev = NULL;
+	}
+
+	if (!test_mode && (priv->fpga_client != NULL)) {
+		i2c_unregister_device(priv->fpga_client);
+		priv->fpga_client = NULL;
+	}
+
+	return tc_dev;
+}
+
+static int dioneir_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tegracam_device *tc_dev;
+	struct dione_struct *priv;
+	int err;
+
+	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev, sizeof(struct dione_struct), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->tc35_client = client;
+	if (test_mode)
+		quick_mode = 1;
+
+	tc_dev = dioneir_probe_one(priv, &dione640_common_ops);
+
+	if (!tc_dev)
+		tc_dev = dioneir_probe_one(priv, &dione1280_common_ops);
+
+	if (!tc_dev)
+		tc_dev = dioneir_probe_one(priv, &dione640_reva_common_ops);
+
+	if (!tc_dev)
+		dev_err(dev, "%s: error, no sensor found\n", __func__);
+	else {
+		err = tegracam_v4l2subdev_register(tc_dev, true);
+		if (err) {
+			dev_err(dev, "tegra camera subdev registration failed\n");
+			tegracam_device_unregister(tc_dev);
+			return err;
+		}
+
+		dev_info(dev, "detected Dione IR sensor\n");
+
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int dioneir_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct dione_struct *priv = (struct dione_struct *)s_data->priv;
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id dioneir_id[] = {
+	{ "dione_ir", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dioneir_id);
+
+static struct i2c_driver dioneir_i2c_driver = {
+	.driver = {
+		.name = "dione_ir",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(dioneir_of_match),
+	},
+	.probe = dioneir_probe,
+	.remove = dioneir_remove,
+	.id_table = dioneir_id,
+};
+module_i2c_driver(dioneir_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Xenics Dione640 and Dione1280");
+MODULE_AUTHOR("Xenics Infrared Solutions / Botond Kardos");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia/drivers/media/i2c/tc358746_regs.h b/nvidia/drivers/media/i2c/tc358746_regs.h
new file mode 100644
index 000000000000..3d730eb944e3
--- /dev/null
+++ b/nvidia/drivers/media/i2c/tc358746_regs.h
@@ -0,0 +1,210 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * tc358746 - Toshiba Parallel to CSI-2 bridge - register names and bit masks
+ *
+ * Convention:
+ * <REGISTER>
+ * <REGISTER>_<BITFIELD>_MASK
+ * <REGISTER>_<BITFIELD>_<VALUE>
+ * <REGISTER>_<BITFIELD>_SET(val = <REGISTER>_<BITFIELD>_<VALUE>)
+ *
+ * References:
+ * REF_01:
+ * - TC358746AXBG/TC358748XBG/TC358748IXBG Functional Specification Rev 1.2
+ */
+
+#ifndef __TC358746_REGS_H
+#define __TC358746_REGS_H
+
+#define TC358746_I2C_ADDR		0x0e
+
+#define CHIPID			0x0000
+#define CHIPID_CHIPID_MASK		GENMASK(15, 8)
+#define CHIPID_REVID_MASK		GENMASK(7, 0)
+
+#define SYSCTL			0x0002
+#define SYSCTL_SLEEP_MASK		BIT(1)
+#define SYSCTL_SRESET_MASK		BIT(0)
+
+#define CONFCTL                 0x0004
+#define CONFCTL_TRIEN_MASK		BIT(15)
+#define CONFCTL_INTE2N_MASK		BIT(13)
+#define CONFCTL_BT656EN_MASK		BIT(12)
+#define CONFCTL_PDATAF_MASK		GENMASK(9, 8)
+#define CONFCTL_PDATAF_SET(val)		(((val << 8) & CONFCTL_PDATAF_MASK))
+#define CONFCTL_PDATAF_MODE0		0
+#define CONFCTL_PDATAF_MODE1		1
+#define CONFCTL_PDATAF_MODE2		2
+#define CONFCTL_PPEN_MASK		BIT(6)
+#define CONFCTL_VVALIDP_MASK		BIT(5)
+#define CONFCTL_HVALIDP_MASK		BIT(4)
+#define CONFCTL_PCLKP_MASK		BIT(3)
+#define CONFCTL_AUTO_MASK		BIT(2)
+#define CONFCTL_DATALANE_MASK		GENMASK(1, 0)
+#define CONFCTL_DATALANE_1		0
+#define CONFCTL_DATALANE_2		1
+#define CONFCTL_DATALANE_3		2
+#define CONFCTL_DATALANE_4		3
+
+#define FIFOCTL			0x0006
+#define DATAFMT			0x0008
+#define DATAFMT_PDFMT_RAW8		0
+#define DATAFMT_PDFMT_RAW10		1
+#define DATAFMT_PDFMT_RAW12		2
+#define DATAFMT_PDFMT_RGB888		3
+#define DATAFMT_PDFMT_RGB666		4
+#define DATAFMT_PDFMT_RGB565		5
+#define DATAFMT_PDFMT_YCBCRFMT_422_8_BIT 6
+#define DATAFMT_PDFMT_RAW14		8
+#define DATAFMT_PDFMT_YCBCRFMT_422_10_BIT 9
+#define DATAFMT_PDFMT_YCBCRFMT_444	10
+#define DATAFMT_PDFMT_MASK		GENMASK(7, 4)
+#define DATAFMT_PDFMT_SET(val)		(((val) << 4) & DATAFMT_PDFMT_MASK)
+#define DATAFMT_UDT_EN_MASK		BIT(0)
+
+#define MCLKCTL			0x000c
+#define MCLKCTL_MCLK_HIGH_MASK		GENMASK(15, 8)
+#define MCLKCTL_MCLK_HIGH_SET(val)	((((val) - 1) << 8) & MCLKCTL_MCLK_HIGH_MASK)
+#define MCLKCTL_MCLK_LOW_MASK		GENMASK(7, 0)
+#define MCLKCTL_MCLK_LOW_SET(val)	(((val) - 1) & MCLKCTL_MCLK_LOW_MASK)
+
+#define PLLCTL0			0x0016
+#define PLLCTL0_PLL_PRD_MASK		GENMASK(15, 12)
+#define PLLCTL0_PLL_PRD_SET(prd)	((((prd) - 1) << 12) & PLLCTL0_PLL_PRD_MASK)
+#define PLLCTL0_PLL_FBD_MASK		GENMASK(8, 0)
+#define PLLCTL0_PLL_FBD_SET(fbd)        (((fbd) - 1) & PLLCTL0_PLL_FBD_MASK)
+
+#define PLLCTL1                 0x0018
+#define PLLCTL1_PLL_FRS_MASK            GENMASK(11, 10)
+#define PLLCTL1_PLL_FRS_SET(frs)        (((frs) << 10) & PLLCTL1_PLL_FRS_MASK)
+#define PLLCTL1_PLL_LBWS_MASK		GENMASK(9, 8)
+#define PLLCTL1_LFBREN_MASK		BIT(6)
+#define PLLCTL1_BYPCKEN_MASK		BIT(5)
+#define PLLCTL1_CKEN_MASK		BIT(4)
+#define PLLCTL1_RESETB_MASK		BIT(1)
+#define PLLCTL1_PLL_EN_MASK		BIT(0)
+
+#define CLKCTL			0x0020
+#define CLKCTL_MCLKDIV_MASK		GENMASK(3, 2)
+#define CLKCTL_MCLKDIV_SET(val)		((val << 2) & CLKCTL_MCLKDIV_MASK)
+#define CLKCTL_MCLKDIV_8		0
+#define CLKCTL_MCLKDIV_4		1
+#define CLKCTL_MCLKDIV_2		2
+
+#define WORDCNT			0x0022
+#define PP_MISC                 0x0032
+#define PP_MISC_FRMSTOP_MASK		BIT(15)
+#define PP_MISC_RSTPTR_MASK		BIT(14)
+
+#define CSI2TX_DATA_TYPE	0x0050
+#define MIPI_PHY_STATUS		0x0062
+#define CSI2_ERROR_STATUS       0x0064
+#define CSI2_ERR_EN             0x0066
+#define CSI2_IDID_ERROR         0x006c
+#define DBG_ACT_LINE_CNT        0x00e0
+#define DBG_LINE_WIDTH		0x00e2
+#define DBG_VERT_BLANK_LINE_CNT	0x00e4
+#define DBG_VIDEO_DATA          0x00e8
+#define FIFOSTATUS              0x00F8
+
+#define CLW_CNTRL               0x0140
+#define CLW_CNTRL_CLW_LANEDISABLE_MASK	BIT(0)
+
+#define D0W_CNTRL               0x0144
+#define D0W_CNTRL_D0W_LANEDISABLE_MASK	BIT(0)
+
+#define D1W_CNTRL		0x0148
+#define D1W_CNTRL_D1W_LANEDISABLE_MASK	BIT(0)
+
+#define D2W_CNTRL		0x014C
+#define D2W_CNTRL_D2W_LANEDISABLE_MASK	BIT(0)
+
+#define D3W_CNTRL		0x0150
+#define D2W_CNTRL_D3W_LANEDISABLE_MASK	BIT(0)
+
+#define STARTCNTRL              0x0204
+#define STARTCNTRL_START_MASK		BIT(0)
+
+#define LINEINITCNT		0x0210
+#define LPTXTIMECNT		0x0214
+#define TCLK_HEADERCNT		0x0218
+#define	TCLK_HEADERCNT_TCLK_ZEROCNT_MASK	GENMASK(15, 8)
+#define TCLK_HEADERCNT_TCLK_PREPARECNT_MASK	GENMASK(6, 0)
+#define	TCLK_HEADERCNT_TCLK_ZEROCNT_SET(val)	((val << 8) & TCLK_HEADERCNT_TCLK_ZEROCNT_MASK)
+#define	TCLK_HEADERCNT_TCLK_PREPARECNT_SET(val)	(val & TCLK_HEADERCNT_TCLK_PREPARECNT_MASK)
+
+#define TCLK_TRAILCNT		0x021C
+#define THS_HEADERCNT		0x0220
+#define	THS_HEADERCNT_THS_ZEROCNT_MASK		GENMASK(14, 8)
+#define	THS_HEADERCNT_THS_PREPARECNT_MASK	GENMASK(6, 0)
+#define	THS_HEADERCNT_THS_ZEROCNT_SET(val)	((val << 8) & THS_HEADERCNT_THS_ZEROCNT_MASK)
+#define	THS_HEADERCNT_THS_PREPARECNT_SET(val)	(val & THS_HEADERCNT_THS_PREPARECNT_MASK)
+
+#define TWAKEUP			0x0224
+#define TCLK_POSTCNT		0x0228
+#define THS_TRAILCNT		0x022C
+#define HSTXVREGCNT		0x0230
+#define HSTXVREGEN              0x0234
+#define HSTXVREGEN_D3M_HSTXVREGEN_MASK	BIT(4)
+#define HSTXVREGEN_D2M_HSTXVREGEN_MASK  BIT(3)
+#define HSTXVREGEN_D1M_HSTXVREGEN_MASK  BIT(2)
+#define HSTXVREGEN_D0M_HSTXVREGEN_MASK  BIT(1)
+#define HSTXVREGEN_CLM_HSTXVREGEN_MASK  BIT(0)
+
+#define TXOPTIONCNTRL           0x0238
+#define TXOPTIONCNTRL_CONTCLKMODE_MASK	BIT(0)
+
+#define CSI_CONTROL             0x040C
+#define CSI_CONTROL_CSI_MODE_MASK       BIT(15)
+#define CSI_CONTROL_HTXTOEN_MASK        BIT(10)
+#define CSI_CONTROL_TXHSMD_MASK         BIT(7)
+#define CSI_CONTROL_NOL_MASK            GENMASK(2, 1)
+#define CSI_CONTROL_NOL_1_MASK          0
+#define CSI_CONTROL_NOL_2_MASK          BIT(1)
+#define CSI_CONTROL_NOL_3_MASK          BIT(2)
+#define CSI_CONTROL_NOL_4_MASK          (BIT(1) | BIT(2))
+#define CSI_CONTROL_EOTDIS_MASK         BIT(0)
+
+#define CSI_STATUS              0x0410
+#define CSI_STATUS_S_WSYNC_MASK		BIT(10)
+#define CSI_STATUS_S_TXACT_MASK		BIT(9)
+#define CSI_STATUS_S_HLT_MASK		BIT(0)
+
+#define CSI_INT			0x0414
+#define CSI_INT_INTHLT_MASK		BIT(3)
+#define CSI_INT_INTER_MASK		BIT(2)
+
+#define CSI_INT_ENA             0x0418
+#define CSI_INT_ENA_IENHLT_MASK		BIT(3)
+#define CSI_INT_ENA_IENER_MASK		BIT(2)
+
+#define CSI_ERR                 0x044C
+#define CSI_ERR_INER_MASK               BIT(9)
+#define CSI_ERR_WCER_MASK		BIT(8)
+#define CSI_ERR_QUNK_MASK		BIT(4)
+#define CSI_ERR_TXBRK_MASK		BIT(1)
+
+#define CSI_ERR_INTENA          0x0450
+#define CSI_ERR_HALT            0x0454
+#define CSI_CONFW               0x0500
+#define CSI_CONFW_MODE_MASK			GENMASK(31, 29)
+#define CSI_CONFW_MODE_SET_MASK			(BIT(31) | BIT(29))
+#define CSI_CONFW_MODE_CLEAR_MASK		(BIT(31) | BIT(30))
+#define CSI_CONFW_ADDRESS_MASK			GENMASK(28, 24)
+#define CSI_CONFW_ADDRESS_CSI_CONTROL_MASK	(BIT(24) | BIT(25))
+#define CSI_CONFW_ADDRESS_CSI_INT_ENA_MASK	(BIT(25) | BIT(26))
+#define CSI_CONFW_ADDRESS_CSI_ERR_INTENA_MASK	(BIT(28) | BIT(26))
+#define CSI_CONFW_ADDRESS_CSI_ERR_HALT_MASK	(BIT(28) | BIT(26) | BIT(24))
+#define CSI_CONFW_DATA_MASK			GENMASK(15, 0)
+
+#define CSIRESET                0x0504
+#define CSIRESET_RESET_CNF_MASK		BIT(1)
+#define CSIRESET_RESET_MODULE_MASK	BIT(0)
+
+#define CSI_INT_CLR             0x050C
+#define CSI_INT_CLR_ICRER_MASK		BIT(2)
+
+#define CSI_START               0x0518
+#define CSI_START_STRT_MASK		BIT(0)
+
+#endif
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi
new file mode 100644
index 000000000000..445635538653
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dione-ir.dtsi
@@ -0,0 +1,344 @@
+/*
+ * Copyright (c) 2021, Xenics Infrared Solutions.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/media/camera.h>
+#include <dt-bindings/platform/t210/t210.h>
+
+/ {
+	host1x {
+		vi_base: vi {
+			num-channels = <1>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				vi_port0: port@0 {
+					reg = <0>;
+					rbpcv2_dione_ir_vi_in0: endpoint {
+						port-index = <0>;
+						bus-width = <2>;
+						remote-endpoint = <&rbpcv2_dione_ir_csi_out0>;
+					};
+				};
+			};
+		};
+
+		csi_base: nvcsi {
+			num-channels = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rbpcv2_dione_ir_csi_in0: endpoint@0 {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione_ir_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rbpcv2_dione_ir_csi_out0: endpoint@1 {
+							remote-endpoint = <&rbpcv2_dione_ir_vi_in0>;
+						};
+					};
+				};
+			};
+		};
+
+		i2c@546c0000 {
+			dione_ir_single_cam0: rbpcv2_dione_ir_a@0e {
+				compatible = "xenics,dione_ir";
+				/* I2C device address */
+				reg = <0x0e>;
+
+				/* V4L2 device node location */
+				devnode = "video0";
+
+				/* Physical dimensions of sensor */
+				physical_w = "7.680";
+				physical_h = "5.760";
+
+				sensor_model = "dione_ir";
+
+				use_sensor_mode_id = "false";
+
+				/**
+				* ==== Modes ====
+				* A modeX node is required to support v4l2 driver
+				* implementation with NVIDIA camera software stack
+				*
+				* == Signal properties ==
+				*
+				* phy_mode = "";
+				* PHY mode used by the MIPI lanes for this device
+				*
+				* tegra_sinterface = "";
+				* CSI Serial interface connected to tegra
+				* Incase of virtual HW devices, use virtual
+				* For SW emulated devices, use host
+				*
+				* pix_clk_hz = "";
+				* Sensor pixel clock used for calculations like exposure and framerate
+				*
+				* readout_orientation = "0";
+				* Based on camera module orientation.
+				* Only change readout_orientation if you specifically
+				* Program a different readout order for this mode
+				*
+				* == Image format Properties ==
+				*
+				* active_w = "";
+				* Pixel active region width
+				*
+				* active_h = "";
+				* Pixel active region height
+				*
+				* pixel_t = "";
+				* The sensor readout pixel pattern
+				*
+				* line_length = "";
+				* Pixel line length (width) for sensor mode.
+				*
+				* == Source Control Settings ==
+				*
+				* Gain factor used to convert fixed point integer to float
+				* Gain range [min_gain/gain_factor, max_gain/gain_factor]
+				* Gain step [step_gain/gain_factor is the smallest step that can be configured]
+				* Default gain [Default gain to be initialized for the control.
+				*     use min_gain_val as default for optimal results]
+				* Framerate factor used to convert fixed point integer to float
+				* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
+				* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
+				* Default Framerate [Default framerate to be initialized for the control.
+				*     use max_framerate to get required performance]
+				* Exposure factor used to convert fixed point integer to float
+				* For convenience use 1 sec = 1000000us as conversion factor
+				* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
+				* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
+				* Default Exposure Time [Default exposure to be initialized for the control.
+				*     Set default exposure based on the default_framerate for optimal exposure settings]
+				*
+				* gain_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_gain_val = ""; (ceil to integer)
+				* max_gain_val = ""; (ceil to integer)
+				* step_gain_val = ""; (ceil to integer)
+				* default_gain = ""; (ceil to integer)
+				* Gain limits for mode
+				*
+				* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_exp_time = ""; (ceil to integer)
+				* max_exp_time = ""; (ceil to integer)
+				* step_exp_time = ""; (ceil to integer)
+				* default_exp_time = ""; (ceil to integer)
+				* Exposure Time limits for mode (sec)
+				*
+				* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_framerate = ""; (ceil to integer)
+				* max_framerate = ""; (ceil to integer)
+				* step_framerate = ""; (ceil to integer)
+				* default_framerate = ""; (ceil to integer)
+				* Framerate limits for mode (fps)
+				*
+				* embedded_metadata_height = "";
+				* Sensor embedded metadata height in units of rows.
+				* If sensor does not support embedded metadata value should be 0.
+				*/
+				mode0 { /* DIONE_IR_MODE_640x480_60FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+
+					active_w = "640";
+					active_h = "480";
+					pixel_t = "rgb_rgb88824";
+					readout_orientation = "0";
+					line_length = "694";
+					/* inherent_gain = "1"; */
+					/* mclk_multiplier = "9.33"; */
+					pix_clk_hz = "20000000";
+
+					/* unused */
+					gain_factor = "16";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; /* 1.00x */
+					max_gain_val = "170"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+
+					/* framerate */
+					framerate_factor = "1000000";
+					min_framerate = "40000000"; /* 40 fps */
+					max_framerate = "62000000"; /* 62 fps */
+					step_framerate = "1";
+					default_framerate = "60020000"; /* 60.020 fps */
+
+					/* unused */
+					min_exp_time = "13"; /* us */
+					max_exp_time = "683709"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "2495"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+				mode1 { /* DIONE_IR_MODE_1280x1024_60FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes";
+					dpcm_enable = "false";
+					cil_settletime = "0";
+
+					active_w = "1280";
+					active_h = "1024";
+					pixel_t = "rgb_rgb88824";
+					readout_orientation = "0";
+					line_length = "1334";
+					/* inherent_gain = "1"; */
+					/* mclk_multiplier = "9.33"; */
+					pix_clk_hz = "83000000";
+
+					/* unused */
+					gain_factor = "16";
+					exposure_factor = "1000000";
+					min_gain_val = "16"; /* 1.00x */
+					max_gain_val = "170"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+
+					/* framerate */
+					framerate_factor = "1000000";
+					min_framerate = "40000000"; /* 40 fps */
+					max_framerate = "62000000"; /* 62 fps */
+					step_framerate = "1";
+					default_framerate = "60756000"; /* 60.756 fps */
+
+					/* unused */
+					min_exp_time = "13"; /* us */
+					max_exp_time = "683709"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "2495"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						rbpcv2_dione_ir_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_dione_ir_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	/* CN 3423-xx SN xxxx 55mm F/1 */
+	lens_dione_ir@RBPCV2 {
+		min_focus_distance = "2000.0"; /* F.R 2m ~ ... */
+		hyper_focal = "0.0";
+		focal_length = "55.0"; /* E.F.L 55mm */
+		f_number = "1.0"; /* F.NO 1.0 */
+		aperture = "0.0";
+	};
+};
+
+/ {
+	tcp: tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+
+		/**
+		* Physical settings to calculate max ISO BW
+		*
+		* num_csi_lanes = <>;
+		* Total number of CSI lanes when all cameras are active
+		*
+		* max_lane_speed = <>;
+		* Max lane speed in Kbit/s
+		*
+		* min_bits_per_pixel = <>;
+		* Min bits per pixel
+		*
+		* vi_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the VI ISO case
+		*
+		* vi_bw_margin_pct = <>;
+		* Vi bandwidth margin in percentage
+		*
+		* max_pixel_rate = <>;
+		* Max pixel rate in Kpixel/s for the ISP ISO case
+		*
+		* isp_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the ISP ISO case
+		*
+		* isp_bw_margin_pct = <>;
+		* Isp bandwidth margin in percentage
+		*/
+		num_csi_lanes = <2>;
+		max_lane_speed = <1500000>;
+		min_bits_per_pixel = <10>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <240000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		/**
+		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
+		 * The first part is the camera_board_id for the module; if the module is in a FFD
+		 * platform, then use the platform name for this part.
+		 * The second part contains the position of the module, ex. "rear" or "front".
+		 * The third part contains the last 6 characters of a part number which is found
+		 * in the module's specsheet from the vendor.
+		 */
+		modules {
+			cam_module0: module0 {
+				badge = "porg_front_RBPCV2";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					pcl_id = "v4l2_sensor";
+					devname = "dione_ir 6-000e";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione_ir_a@0e";
+				};
+				cam_module0_drivernode1: drivernode1 {
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione_ir@RBPCV2/";
+				};
+			};
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi
new file mode 100644
index 000000000000..c896b3633e82
--- /dev/null
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2018-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra210-camera-rbpcv2-dione-ir.dtsi"
+
+#define CAM1_PWDN		TEGRA_GPIO(S, 7)
+
+/ {
+    host1x {
+		i2c@546c0000 {
+			clock-frequency = <1000000>;
+
+			rbpcv2_dione_ir_a@0e {
+				status = "disabled";
+				reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+    gpio@6000d000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = < CAM1_PWDN 0 >;
+			label = "cam1-pwdn";
+		};
+	};
+};
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
index 74196e10d0db..0f6a0ba271fb 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera.dtsi
@@ -15,7 +15,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #include "tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
-#include "tegra210-porg-camera-rbpcv2-imx219.dtsi"
+#include "tegra210-porg-camera-rbpcv2-dione-ir.dtsi"
 
 / {
 	tegra-camera-platform {
diff --git a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
index 93ec6e3876f4..9e3a5d5deaff 100644
--- a/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/porg-plugin-manager/tegra210-porg-plugin-manager.dtsi
@@ -170,7 +170,7 @@
                         };
                 };
 
-		fragement@9 {
+		fragment@9 {
 			ids = "<3448-0000-300", "<3448-0002-300" , ">=3448-0003-000";
 			override@0 {
 				target = <&max77620_ldo6>;
@@ -185,14 +185,9 @@
 					non-removable;
 				};
 			};
-			/* IMX219 single sensor module */
+
+			/* common settings for Dione640 and Dione1280 cameras */
 			override@2 {
-				target = <&imx219_single_cam0>;
-				_overlay_ {
-					status = "okay";
-				};
-			};
-			override@3 {
 				target = <&cam_module0>;
 				_overlay_ {
 					status = "okay";
@@ -201,88 +196,100 @@
 					orientation = "1";
 				};
 			};
+
+			/* Enable VI ports */
+			override@3 {
+				target = <&vi_base>;
+				_overlay_ {
+					num-channels=<1>;
+				};
+			};
 			override@4 {
-				target = <&cam_module0_drivernode0>;
+				target = <&vi_port0>;
 				_overlay_ {
 					status = "okay";
-					pcl_id = "v4l2_sensor";
-					devname = "imx219 6-0010";
-					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_imx219_a@10";
 				};
 			};
+
+			/* Enable CSI ports */
 			override@5 {
-				target = <&cam_module0_drivernode1>;
+				target = <&csi_base>;
 				_overlay_ {
-					status = "okay";
-					pcl_id = "v4l2_lens";
-					proc-device-tree = "/proc/device-tree/lens_imx219@RBPCV2/";
+					num-channels=<1>;
 				};
 			};
-			/* Enable VI ports */
 			override@6 {
-				target = <&vi_base>;
+				target = <&csi_chan0>;
 				_overlay_ {
-					num-channels=<1>;
+					status = "okay";
 				};
 			};
 			override@7 {
-				target = <&vi_port0>;
+				target = <&csi_chan0_port0>;
 				_overlay_ {
 					status = "okay";
 				};
 			};
 			override@8 {
-				target = <&rbpcv2_imx219_vi_in0>;
+				target = <&csi_chan0_port1>;
 				_overlay_ {
 					status = "okay";
-					port-index = <0>;
-					bus-width = <2>;
-					remote-endpoint = <&rbpcv2_imx219_csi_out0>;
 				};
 			};
-			/* Enable CSI ports */
+
+			/* dione_ir single sensor module */
 			override@9 {
-				target = <&csi_base>;
+				target = <&dione_ir_single_cam0>;
 				_overlay_ {
-					num-channels=<1>;
+					status = "okay";
 				};
 			};
 			override@10 {
-				target = <&csi_chan0>;
+				target = <&cam_module0_drivernode0>;
 				_overlay_ {
 					status = "okay";
+					pcl_id = "v4l2_sensor";
+					devname = "dione_ir 6-000e";
+					proc-device-tree = "/proc/device-tree/host1x/i2c@546c0000/rbpcv2_dione_ir_a@0e";
 				};
 			};
 			override@11 {
-				target = <&csi_chan0_port0>;
+				target = <&cam_module0_drivernode1>;
 				_overlay_ {
 					status = "okay";
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_dione_ir@RBPCV2/";
 				};
 			};
 			override@12 {
-				target = <&rbpcv2_imx219_csi_in0>;
+				target = <&rbpcv2_dione_ir_vi_in0>;
 				_overlay_ {
 					status = "okay";
 					port-index = <0>;
 					bus-width = <2>;
-					remote-endpoint = <&rbpcv2_imx219_out0>;
+					remote-endpoint = <&rbpcv2_dione_ir_csi_out0>;
 				};
 			};
 			override@13 {
-				target = <&csi_chan0_port1>;
+				target = <&rbpcv2_dione_ir_csi_in0>;
 				_overlay_ {
 					status = "okay";
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_dione_ir_out0>;
 				};
 			};
 			override@14 {
-				target = <&rbpcv2_imx219_csi_out0>;
+				target = <&rbpcv2_dione_ir_csi_out0>;
 				_overlay_ {
 					status = "okay";
-					remote-endpoint = <&rbpcv2_imx219_vi_in0>;
+					remote-endpoint = <&rbpcv2_dione_ir_vi_in0>;
 				};
 			};
+
+
 			/* tegra-camera-platform settings */
-			override@15 {
+			override@20 {
 				target = <&tcp>;
 				_overlay_ {
 					num_csi_lanes = <2>;
@@ -295,7 +302,7 @@
 					isp_bw_margin_pct = <25>;
 				};
 			};
-			override@16 {
+			override@21 {
 				target = <&cam_module1>;
 				_overlay_ {
 					status = "disabled";
diff --git a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
index 2a7d84445089..8917c3021818 100644
--- a/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
+++ b/nvidia/platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
@@ -28,7 +28,7 @@
 #include "porg-platforms/tegra210-pinmux-drive-sdmmc-common.dtsi"
 #include "porg-platforms/tegra210-porg-pwm-fan.dtsi"
 #include "porg-platforms/tegra210-porg-camera.dtsi"
-#include "porg-platforms/tegra210-porg-camera-rbpcv2-imx219.dtsi"
+#include "porg-platforms/tegra210-porg-camera-rbpcv2-dione-ir.dtsi"
 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
 #include <t210-common-platforms/tegra210-ers-hdmi-e2190-1100-a00.dtsi>
 #include <t210-common-platforms/tegra210-dp.dtsi>
-- 
2.25.1

